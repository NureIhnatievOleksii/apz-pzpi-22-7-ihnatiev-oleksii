Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії




Звіт з практичної роботи № 1
з дисципліни «Архітектура програмного забезпечення»




Перевірив                                                         		Виконав 
ст. викладач ПІ                                                        		ст. групи ПЗПІ-22-7 
Сокорчук Ігор Петрович                                    		Ігнатьєв О.Г.







Харків 2025
1 ІСТОРІЯ ЗМІН

№
Дата
Версія звіту
Опис змін та виправлень
1
19.04.2025
0.1
Початкове створення звіту


2 ЗАВДАННЯ

1. Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ»
(із книг: Ґамма, “ООП. Патерни проєктування”, GoF, крім патерна Singletone)
2. Створити та оформити слайди презентації доповіді
3. Створити та опублікувати на YouTube відеозапис доповіді
4. Оформити та завантажити на dl.nure.ua звіт до виконаної роботи
5. При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua
6. Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main
7. Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань
8. Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub
9. Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1


3 ОПИС ВИКОНАНОЇ РОБОТИ

     У цій роботі було здійснено глибоке дослідження, аналіз і реалізацію шаблону проєктування Command, що дозволяє інкапсулювати запити як окремі об'єкти. Це забезпечує гнучкість у реалізації операцій, можливість відкладеного виконання, реєстрації історії дій і повторного використання команд. Нижче описано основні етапи реалізації.

     3.1 Теоретичне дослідження концепції патерну
     На початковому етапі був проведений аналіз літератури та сучасних підходів до застосування поведінкових патернів. Встановлено, що Command дозволяє:
• Відокремити об'єкт, який ініціює операцію, від об'єкта, який її виконує.
• Створювати черги завдань, підтримувати історію дій (наприклад, для реалізації undo/redo).
• Полегшити додавання нових команд без зміни існуючого коду інвокера.
Цей шаблон часто використовується в UI-компонентах, при створенні планувальників завдань, а також у складних системах, що потребують високого рівня гнучкості.

     3.2 Проєктування архітектури
     На основі аналізу було розроблено концептуальну архітектуру застосування патерну Command:
• Основні компоненти:
o Command (інтерфейс): описує метод execute(), який реалізують конкретні команди.
o ConcreteCommand: реалізує інтерфейс Command, інкапсулюючи конкретну дію.
o Receiver: об’єкт, що виконує фактичну логіку операції.
o Invoker: зберігає посилання на об'єкти команд і ініціює їх виконання.
     Діаграма демонструє, як інвокер керує командами, не знаючи деталей їх реалізації, що забезпечує слабку зв’язаність.

     3.2 Розробка концептуальної архітектури
     На основі аналізу патерна Command було створено концептуальну модель системи, у якій основну роль відіграє механізм делегування завдань через команди:
• Побудовано архітектурну схему, де Command-інтерфейс виступає посередником між ініціатором дії (Invoker) та її виконавцем (Receiver). Команди представлені окремими класами, кожен з яких реалізує певну логіку.
• Визначено ключові компоненти системи:
o Command: визначає стандартний інтерфейс для виконання дій.
o ConcreteCommand: реалізує конкретну поведінку та делегує запит до відповідного отримувача.
o Receiver: безпосередньо виконує операцію, визначену командою.
o Invoker: відповідальний за зберігання та ініціацію команд без знання їх внутрішньої реалізації.
• Гнучкість і масштабованість: використання патерна Command дозволяє легко додавати нові команди без зміни існуючої структури, що сприяє еволюції системи з мінімальними витратами на рефакторинг.
     Застосування даного підходу забезпечило чітку модульну організацію та відповідність принципам об’єктно-орієнтованого програмування.

     
     
     3.4 Практична реалізація на базі TypeScript
Під час реалізації було сформовано структуру системи, що відповідає патерну Command:
• Реалізація отримувачів дій: створено окремі компоненти, відповідальні за виконання конкретних функцій системи.
• Реалізація команд: для кожного типу дії створено окремі класи, які реалізують інтерфейс команди та містять посилання на отримувачів.
• Ініціація виконання: Invoker отримує команду через публічний метод і викликає її, не знаючи деталей реалізації, що дозволяє централізовано керувати логікою виконання.
• Документація: реалізація супроводжувалась коментарями, які описують функціональність кожного елементу, що спрощує супровід та подальший розвиток.
     Використання TypeScript забезпечило перевірку типів ще на етапі компіляції, що значно знизило ризик помилок і покращило стабільність коду.

     3.4 Оцінка ефективності та демонстрація роботи
     Система була протестована з метою перевірки правильності реалізації патерна Command:
• Демонстрація виконання: під час тестування команди успішно ініціювались та викликали відповідні дії в отримувачах.
• Зниження зв’язаності: завдяки застосуванню патерна було досягнуто низького рівня залежності між об’єктами, що підтверджує правильність обраного підходу.
• Аналіз модульності: реалізація виявилась зручною для масштабування — додавання нових команд можливе без зміни існуючих компонентів системи, що демонструє відповідність сучасним вимогам до гнучкості архітектури.

     3.5 Науково-технічні аспекти та рекомендації
     Під час реалізації були враховані такі аспекти:
• Принципи SOLID: особлива увага приділялась принципам єдиної відповідальності та відкритості до розширення, що забезпечує легкість підтримки.
• Інкапсуляція та абстрагування: командна структура дозволила ізолювати логіку виконання дій від логіки їх виклику, що зробило систему більш гнучкою та безпечною.
• Масштабованість: завдяки незалежності між компонентами система може розвиватись без ризику порушення вже реалізованого функціоналу.
На основі проведеного аналізу рекомендовано використовувати патерн Command у проєктах, де необхідно чітко відділити ініціатора дії від її виконавця, а також де важливо впровадити історію дій, можливість скасування або повтору операцій.

ВИСНОВКИ

     У ході виконаної роботи було підтверджено ефективність застосування патерну Command для організації взаємодії між ініціаторами та виконавцями дій у програмній системі. Розроблена архітектурна модель і практична реалізація з використанням TypeScript продемонстрували, як за допомогою інкапсуляції запитів у вигляді окремих об’єктів можна досягти високої гнучкості, зниження зв’язаності компонентів та покращення модульності. Отримані результати свідчать про доцільність використання патерну Command у системах, що потребують масштабованості, керування виконанням операцій та дотримання принципів об'єктно-орієнтованого проєктування. Результати дослідження можуть стати основою для подальшого впровадження у проєктах зі складною бізнес-логікою та динамічними вимогами.

ДОДАТОК A



Відеозапис доповіді на YouTube: https://youtu.be/GhTQTa4ENe8?si=WbWxt0tim7l-UKws

ДОДАТОК Б


Рисунок Б.1 – Заголовок 
 Рисунок Б.2 – Що таке патерн Command? 
 Рисунок Б.3 – Коли варто використовувати Command 
 Рисунок Б.4 – Учасники патерна 

 Рисунок Б.5 – UML-діаграма 
 Рисунок Б.6 – Приклад у реальному житті (теорія) 
 Рисунок Б.7 – Приклад 1 — Увімкнення світла (до і після Command) 

 Рисунок Б.8 – Приклад 2 — Вимкнення комп’ютера (до і після Command)


 Рисунок Б.9 – Приклад коду (наприклад Java) 
 Рисунок Б.10 – Переваги патерна Command 
 Рисунок Б.11 – Недоліки патерна Command 

Рисунок Б.12 – Висновок


ДОДАТОК В

// До: прямий виклик методу

public class RemoteControl {
    private Light light;

    public RemoteControl(Light light) {
        this.light = light;
    }

    public void pressButton() {
        light.on();  // Пряма залежність
    }
}

// Після: використання патерна Command

public class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) { this.light = light; }
    public void execute() { light.on(); }
}

public class RemoteControl {
    private Command command;
    public RemoteControl(Command command) {
        this.command = command;
    }
    public void pressButton() {
        command.execute();  // Гнучкість
    }
}

// До: пряма взаємодія

public class ShutdownManager {
    private Computer computer;

    public ShutdownManager(Computer computer) {
        this.computer = computer;
    }

    public void shutdown() {
        computer.turnOff();  // Жорстке зв’язування
    }
}

// Після: інкапсульована команда
public class ShutdownCommand implements Command {
    private Computer computer;
    public ShutdownCommand(Computer computer) { this.computer = computer; }
    public void execute() { computer.turnOff(); }
}

public class ShutdownManager {
    private Command command;
    public ShutdownManager(Command command) {
        this.command = command;
    }
    public void shutdown() {
        command.execute();  // Гнучкість і масштабованість
    }
}

// Приклад коду (наприклад Java)

public interface Command {
    void execute();
}

public class LightOnCommand implements Command {
    private Light light;
    public LightOnCommand(Light light) { this.light = light; }
    public void execute() { light.on(); }
}

